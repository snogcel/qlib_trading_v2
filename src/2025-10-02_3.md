
class HummingbotQuantileBacktester:


def quantiles_to_probabilities(q10, q50, q90, spread_thresh) # touch typing


def calculate_target_pct(q10, q50, q90, abs_q50, tier_confidence, spreadh_thresh, signal_thresh, sizing_method, target_vol)


def _simple_sizing(q10, q50, q90, abs_q50, tier_confidence, spread_thresh, signal_thresh)



def _kelly_sizing(q10, q50, q90, tier_confidence, spreadh_thresh, signal_thresh) # bet sizing to reduce risk


def _volatility_sizing(q10, q50, q90, tier_confidence,spreadh_thresh,target_vol) # alternate to Kelly, for bet sizing once again

def _sharpe_sizing(q10, q50, q90, tier_confidence)

def _risk_parity_sizing(q10, q50, q90, tier_confidence, portfolio_vol)

def _enhanced_sizing(q10, q50, q90, abs_q50, tier_confidence, spreadh_thresh, signal_thresh, target-vol)

def prob_up_piecewise(q10, q50, q90)


def generate_hummingbot_signal(row)


# how to learn

# signal = Dict = Dictionary File = Python Data Structure

def execute_trade(signal, current_price,timestamp)

def _execute_position_change(position_change, price, timestamp, signal)

# Record trade with enhanced information including PnL
        trade = {
            "timestamp": timestamp,
            "side": side,
            "quantity": abs(position_change),
            "price": price,
            "fee_cost": fee_cost,
            "slippage_cost": slippage_cost,
            "position_before": position_before,
            "position_after": self.position,
            "balance_after": self.balance,
            "pnl": trade_pnl,  # Add PnL to trade record
            "entry_price": self.position_entry_price,
            "signal": signal,
            "trade_type": "POSITION_CLOSURE" if signal.get("is_position_closure", False) else "DIRECTIONAL",
            "original_signal": signal.get("signal_direction", "UNKNOWN")
        }


def _close_position(price, timestamp, reason, close_details)


def _record_hold_state(price, timestamp, hold_reason, signal)

def _should_close_on_neutral(signal, current_price)


def run_backtest(df, price_data, price_col, return_col)

"""
        Run Hummingbot-style backtest on prediction data with real price data
        
        Args:
            df: DataFrame with predictions (q10, q50, q90, etc.)
            price_data: DataFrame with actual price data (datetime index, 'close' column)
            price_col: Column name for price in price_data
            return_col: Column name for returns in df (for validation)
        """


def _create_results_dataframe()

def calculate_metrics(results_df)

def generate_report(results_df)

...

def save_results(results_df, output_dir)

def _create_signal_analysis_csv(results_df, output_path)


def _create_signal_summary_stats(signal_df)


def load_price_data(price_file)

# load 60-minute price data for backtesting



def run_hummingbot_backtest(price_file)

"""
    Example of running Hummingbot-style backtest with real price data
    
    Args:
        price_file: Path to CSV with 60min price data
    """
    # Load prediction data
    df = pd.read_csv("df_all_macro_analysis.csv") # bug located here


if __name__ == "__main__":
    backtester, results = run_hummingbot_backtest()





